// Задание 1:
// Начнем с самого простого, чтобы "пощупать" передачу функции как аргумента в синхронном коде.
// Создай функцию calculate(a, b, operation). Она должна принимать:
// 1. Два числа (a и b).
// 2. Колбэк-функцию (operation), которая будет производить над ними математическое действие.
// Внутри calculate должна вызвать колбэк operation, передав ему a и b, а затем вывести результат в консоль в формате: Результат: [число].
// Создай две отдельные функции: add (которая складывает два числа) и multiply (которая их умножает).
// Вызови calculate дважды: один раз с функцией add и второй раз с multiply, чтобы проверить её работу.

function add(a, b) {
  return a + b;
}

function multiply(a, b) {
  return a * b;
}

function calculate(a, b, operation) {
  return operation(a, b);
}

let result = calculate(5, 2, add);
console.log(`Результат: ${result}`); // Результат: 7

result = calculate(5, 2, multiply);
console.log(`Результат: ${result}`); // Результат: 10

// Задание 2:
// Напиши функцию fetchData(callback), которая будет имитировать задержку при получении данных с сервера.
// 1. Функция fetchData принимает один аргумент — колбэк.
// 2. Внутри fetchData используй setTimeout, чтобы создать искусственную задержку в 2 секунды (2000 миллисекунд).
// 3. После того как setTimeout отсчитает 2 секунды, он должен вызвать переданный колбэк.
// 4. В этот колбэк нужно передать объект с данными, например: { name: "Сергей", role: "Админ" }.
// 5. Вызови fetchData и передай ей колбэк, который просто выведет полученные данные в консоль.

function outputData(data) {
  console.log(`Получены данные: ${data}`);
}

function fetchData(callback) {
  const fetch = { name: 'Сергей', role: 'Админ' };
  setTimeout(() => callback(JSON.stringify(fetch)), 2000);
}

fetchData(outputData); // Получены данные: {"name":"Сергей","role":"Админ"}

// Задание 3:
// Модернизируем нашу функцию fetchData, чтобы она могла не только успешно загружать данные, но и "падать" с ошибкой.
// 1. Измени функцию fetchData так, чтобы она имитировала вероятность ошибки:
// - Внутри сгенерируй случайное число от 0 до 1 (Math.random()).
// - Если число > 0.5 (успех): через 2 секунды вызови колбэк, передав ему null первым аргументом и объект с данными ({...}) вторым.
// - Если число <= 0.5 (ошибка): через 2 секунды вызови колбэк, передав ему объект ошибки (new Error("Не удалось загрузить данные")) первым аргументом и null вторым.
// 2. Измени код, который вызывает fetchData. Твой колбэк теперь должен принимать два аргумента (err, data).
// 3. Внутри колбэка сначала проверь, пришла ли ошибка.
// - Если err существует, выведи в консоль сообщение об ошибке.
// - Если err равен null, выведи в консоль полученные данные.
// Запусти код несколько раз, чтобы увидеть оба исхода — и успешный, и ошибочный.

function outputData(err, data) {
  if (err) {
    console.error(err.message); // НЕ console.log и именно err.message
    return; // обязательно нужно остановить выполнение, если есть ошибка
  }

  console.log(`Получены данные: ${data}`);
}

function fetchData(callback) {
  const fetch = { name: 'Сергей', role: 'Админ' };
  let randomNum = Math.random();

  if (randomNum > 0.5) {
    setTimeout(() => callback(null, JSON.stringify(fetch)), 2000);
  } else {
    setTimeout(
      () => callback(new Error('Не удалось загрузить данные!'), null),
      2000
    );
  }
}

fetchData(outputData); // Получены данные: {"name":"Сергей","role":"Админ"}
fetchData(outputData); // Не удалось загрузить данные!
